//package frc5409.vision;
//import java.io.File;
//import java.io.FileWriter;
//import java.io.IOException;
//import java.util.ArrayList;
//import java.util.List;
//import java.util.Map;
//import java.util.stream.Collectors;
//import java.util.HashMap;
//
//import org.opencv.core.*;
//import org.opencv.core.Core.*;
//import org.opencv.features2d.FeatureDetector;
//import org.opencv.imgcodecs.Imgcodecs;
//import org.opencv.imgproc.*;
//import org.opencv.objdetect.*;
//
///**
//* GripPipeline class.
//*
//* <p>An OpenCV pipeline generated by GRIP.
//*
//* @author GRIP
//*/
//public class GripPipeline {
//
//	//Outputs
//	private Mat hsvThresholdOutput = new Mat();
//	private Mat cvErodeOutput = new Mat();
//	private Mat maskOutput = new Mat();
//
//	static {
//		System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
//	}
//
//	/**
//	 * This is the primary method that runs the entire pipeline and updates the outputs.
//	 */
//	public void process(Mat source0) {
//		// Step HSV_Threshold0:
//		Mat hsvThresholdInput = source0;
//		double[] hsvThresholdHue = {0.0, 166.17747440273038};
//		double[] hsvThresholdSaturation = {0.0, 255.0};
//		double[] hsvThresholdValue = {249.03776978417264, 255.0};
//		hsvThreshold(hsvThresholdInput, hsvThresholdHue, hsvThresholdSaturation, hsvThresholdValue, hsvThresholdOutput);
//
//		// Step CV_erode0:
//		Mat cvErodeSrc = hsvThresholdOutput;
//		Mat cvErodeKernel = new Mat();
//		Point cvErodeAnchor = new Point(-1, -1);
//		double cvErodeIterations = 1;
//		int cvErodeBordertype = Core.BORDER_CONSTANT;
//		Scalar cvErodeBordervalue = new Scalar(-1);
//		cvErode(cvErodeSrc, cvErodeKernel, cvErodeAnchor, cvErodeIterations, cvErodeBordertype, cvErodeBordervalue, cvErodeOutput);
//
//		// Step Mask0:
//		Mat maskInput = source0;
//		Mat maskMask = cvErodeOutput;
//		mask(maskInput, maskMask, maskOutput);
//
//	}
//
//	/**
//	 * This method is a generated getter for the output of a HSV_Threshold.
//	 * @return Mat output from HSV_Threshold.
//	 */
//	public Mat hsvThresholdOutput() {
//		return hsvThresholdOutput;
//	}
//
//	/**
//	 * This method is a generated getter for the output of a CV_erode.
//	 * @return Mat output from CV_erode.
//	 */
//	public Mat cvErodeOutput() {
//		return cvErodeOutput;
//	}
//
//	/**
//	 * This method is a generated getter for the output of a Mask.
//	 * @return Mat output from Mask.
//	 */
//	public Mat maskOutput() {
//		return maskOutput;
//	}
//
//
//	/**
//	 * Segment an image based on hue, saturation, and value ranges.
//	 *
//	 * @param input The image on which to perform the HSL threshold.
//	 * @param hue The min and max hue
//	 * @param sat The min and max saturation
//	 * @param val The min and max value
//	 * @param output The image in which to store the output.
//	 */
//	private void hsvThreshold(Mat input, double[] hue, double[] sat, double[] val,
//	    Mat out) {
//		Imgproc.cvtColor(input, out, Imgproc.COLOR_BGR2HSV);
//		Core.inRange(out, new Scalar(hue[0], sat[0], val[0]),
//			new Scalar(hue[1], sat[1], val[1]), out);
//	}
//
//	/**
//	 * Expands area of lower value in an image.
//	 * @param src the Image to erode.
//	 * @param kernel the kernel for erosion.
//	 * @param anchor the center of the kernel.
//	 * @param iterations the number of times to perform the erosion.
//	 * @param borderType pixel extrapolation method.
//	 * @param borderValue value to be used for a constant border.
//	 * @param dst Output Image.
//	 */
//	private void cvErode(Mat src, Mat kernel, Point anchor, double iterations,
//		int borderType, Scalar borderValue, Mat dst) {
//		if (kernel == null) {
//			kernel = new Mat();
//		}
//		if (anchor == null) {
//			anchor = new Point(-1,-1);
//		}
//		if (borderValue == null) {
//			borderValue = new Scalar(-1);
//		}
//		Imgproc.erode(src, dst, kernel, anchor, (int)iterations, borderType, borderValue);
//	}
//
//	/**
//	 * Filter out an area of an image using a binary mask.
//	 * @param input The image on which the mask filters.
//	 * @param mask The binary image that is used to filter.
//	 * @param output The image in which to store the output.
//	 */
//	private void mask(Mat input, Mat mask, Mat output) {
//		mask.convertTo(mask, CvType.CV_8UC1);
//		Core.bitwise_xor(output, output, output);
//		input.copyTo(output, mask);
//	}
//
//
//
//
//}
//
